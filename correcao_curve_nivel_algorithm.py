# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CorrecaoCurvaNivel
                                 A QGIS plugin
 Este plugin identifica e corrige linhas de curva de nível que intersectam vetores de massa d'água.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-21
        copyright            : (C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius
        email                : e.tadeu.eb@ime.eb.br; joao.pereira@ime.eb.br; viniciusmagalhaes@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'
__date__ = '2023-11-21'
__copyright__ = '(C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterVectorLayer,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsFeatureSink,
    QgsGeometry,
    QgsWkbTypes,
    QgsProcessing,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterEnum,
    QgsProcessingException,
    QgsProcessingParameterField,
    QgsProject,
    QgsVectorLayer
)
import processing
from qgis.PyQt.QtCore import QVariant, QCoreApplication
from math import cos, radians


class CorrecaoCurvaNivelAlgorithm(QgsProcessingAlgorithm):

    INPUT_VECTOR = 'INPUT_VECTOR'
    INPUT_FIELD =  'INPUT_FIELD'
    INPUT_AGUA = 'INPUT_AGUA'
    INPUT_SCALE = 'INPUT_SCALE'
    CUSTOM_SCALE = 'CUSTOM_SCALE'
    BUFFER_SIZE = 'BUFFER_SIZE'
    OUTPUT = 'OUTPUT'
    SELECTED = 'SELECTED'
    MOLDURA = 'MOLDURA'
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_VECTOR, 
                self.tr("Insira as curvas de nível"),
                [QgsProcessing.TypeVectorLine]
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SELECTED, self.tr("Process only selected features")
            )
        )
        self.addParameter(
            QgsProcessingParameterField(
                'INPUT_FIELD',
                self.tr('Selecione o atributo de cota'), 
                type=QgsProcessingParameterField.Numeric, 
                parentLayerParameterName='INPUT_VECTOR',
                defaultValue = 'cota')
            )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_AGUA,
                self.tr("Insira a camada de massa d'água"),
                types=[QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterEnum(
                self.INPUT_SCALE,
                self.tr("Selecione a escala"),
                options=['1/25.000', '1/50.000', '1/100.000', '1/250.000', 'Personalizada'],
                defaultValue=0
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.CUSTOM_SCALE,
                self.tr("Insira a escala personalizada (apenas se 'Personalizada' for selecionada)"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_SIZE,
                self.tr("Tamanho do buffer em torno das massas d'água"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.MOLDURA,
                self.tr("Insira a camada de moldura"),
                types=[QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Curvas de Nível Ajustadas')
            )
        )
    
    def processAlgorithm(self, parameters, context, feedback):
        """
        Executa o processamento principal do algoritmo.
        """
        curvas = self.parameterAsVectorLayer(parameters, self.INPUT_VECTOR, context)
        cota_field = self.parameterAsFields(parameters,'INPUT_FIELD', context )
        massas = self.parameterAsVectorLayer(parameters, self.INPUT_AGUA, context)
        scale_option = self.parameterAsEnum(parameters, self.INPUT_SCALE, context)
        custom_scale = self.parameterAsDouble(parameters, self.CUSTOM_SCALE, context)
        buffer_size = self.parameterAsDouble(parameters, self.BUFFER_SIZE, context)
        onlySelected = self.parameterAsBool(parameters, self.SELECTED, context)
        moldura = self.parameterAsVectorLayer(parameters, self.MOLDURA, context)

        # Criação de uma camada somente com as feições selecionadas
        if onlySelected == False: inputLayer = curvas
        else: 
            crs = curvas.sourceCrs()
            inputLayer = QgsVectorLayer(f"{QgsWkbTypes.displayString(curvas.wkbType())}?crs={crs.authid()}", "feições_selecionadas", "memory")
            inputLayer.dataProvider().addAttributes(curvas.fields())
            inputLayer.updateFields()
            inputFeat = curvas.selectedFeatures()
            inputLayer.dataProvider().addFeatures(inputFeat)
            inputLayer.updateExtents()
        
        # A variável scale refere-se ao denominador de escala
        if scale_option == 4:  # Personalizada
            if custom_scale <= 0:
                raise QgsProcessingException(self.tr("A escala personalizada deve ser um valor positivo."))
            scale = custom_scale
        else:
            scales = [25000, 50000, 100000, 250000]
            scale = scales[scale_option]

        (sink, dest_id) = self.parameterAsSink(parameters, 
                                               self.OUTPUT,
                                                context,
                                                curvas.fields(),
                                                QgsWkbTypes.LineString,
                                                curvas.sourceCrs())

        feedback.setProgressText('Procurando e corrigindo geometrias inválidas nas camadas de vetores...')

        # Correção de geometrias inválidas nas camadas de vetores
        curves = processing.run("native:fixgeometries",
                                {'INPUT':inputLayer,
                                 'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        water = processing.run("native:fixgeometries", 
                               {'INPUT':massas,
                                'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        total = 100.0 / 6

        moldura_line = processing.run("native:polygonstolines",
                                {'INPUT': moldura,
                                'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
        #feedback.setProgressText(f'A camada de linhas no contorno {boundary} é do tipo {type(boundary)}')
        # Adicionar a camada de contorno ao projeto
        QgsProject.instance().addMapLayer(moldura_line)
        feedback.pushInfo(f'Foi criada a linha de moldura {moldura_line}')

        feedback.setProgressText('Procurando e identificando as intersecções entre as camadas de vetores...')

        # 1) Obtenção da intersecção das curvas de nível com as massas d'água
        intersection = processing.run("native:intersection",
                                      {'INPUT':curves,
                                       'OVERLAY':water,
                                       'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        #feedback.setProgressText(f'A camada buffer {intersection} é do tipo {type(intersection)}')
        QgsProject.instance().addMapLayer(intersection)
        feedback.setProgress(int(1 * total))

        feedback.setProgressText(f'A camada de intersecção {intersection} indica que há {intersection.featureCount()} flags')
        
        cn_adequadas = curves

        for massa in water.getFeatures():
            geom = massa.geometry()
            cotas = list()
            #bbox = geom.boundingBox() #Bbox da área da massa dágua

            for line in intersection.getFeatures():
                geom_inter = line.geometry()

                if geom_inter.within(geom):
                    cota = line[cota_field[0]] #Aqui ele pega a string 'cota'
                    cotas.append(cota)
                    feedback.pushInfo(f'A feição {line} possui a cota {cota} e está dentro da massa {massa}.')
            feedback.pushInfo(f'A massa {massa} possui a seguinte lista de cotas intersectantes {cotas}.')
            
            cn_adequadas.startEditing()
            if len(cotas) > 0:
            # 2) Inserção de n camada de buffer em torno das massas d'água
                buffers = list()
                if buffer_size:
                    feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                    
                    #Caso seja um buffer personalizado, ele verifica se o sistema é geográfico e converte no equivalente a graus
                    if curvas.crs().isGeographic():
                        extent = curvas.extent()
                        centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                        buffer_size_graus = buffer_size / (111320 * cos(radians(centroid_lat)))
                        #feedback.pushInfo(f'Para sistema de coordenadas geográficas, o buffer de {buffer_size} será de {buffer_size_graus}° na latitude média de {centroid_lat}°.')
                        
                        for i in range (0, len(cotas)):
                            buffer = geom.buffer(buffer_size_graus*(i+1), 5)
                            crs = massas.sourceCrs()
                            buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                            buffer_vector.dataProvider().addAttributes(massas.fields())
                            buffer_vector.updateFields()
                            buffer_feat = QgsFeature()
                            buffer_feat.setGeometry(buffer)
                            buffer_feat.setAttributes(massa.attributes())
                            buffer_vector.dataProvider().addFeatures([buffer_feat])
                            buffer_vector.updateExtents()
                            
                            QgsProject.instance().addMapLayer(buffer_vector)
                            buffers.append(buffer_vector) #Lista de buffers em camada
                        feedback.pushInfo(f'A massa {massa} está com essa lista de buffers {buffers}.')
                        
                    else:
                        for i in range (0, len(cotas)):
                            buffer = geom.buffer(buffer_size*(i+1), 5)
                            crs = massas.sourceCrs()
                            buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                            buffer_vector.dataProvider().addAttributes(massas.fields())
                            buffer_vector.updateFields()
                            buffer_feat = QgsFeature()
                            buffer_feat.setGeometry(buffer)
                            buffer_feat.setAttributes(massa.attributes())
                            buffer_vector.dataProvider().addFeatures([buffer_feat])
                            buffer_vector.updateExtents()
                            QgsProject.instance().addMapLayer(buffer_vector)
                            buffers.append(buffer_vector) #Lista de buffers em camada
                        feedback.pushInfo(f'A massa {massa} está com essa lista de buffers {buffers}.')
                        
                        #feedback.setProgressText(f'A camada buffer {buffer} é do tipo {type(buffer)}')
                        # Adicionar a camada de buffer ao projeto
                        

                else:
                    lim_aquidade = 0.0002 # O limite da aquidade visual é de 0,2mm (0,0002m)
                    if curvas.crs().isGeographic():
                        extent = curvas.extent()
                        centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                        buffer_size_meters = lim_aquidade * scale
                        buffer_size = buffer_size_meters / (111320 * cos(radians(centroid_lat)))

                        #feedback.pushInfo(f'Para a escala de 1/{scale}, o buffer será de {buffer_size}° na latitude média de {centroid_lat}°.')
                        feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                        
                        for i in range (0, len(cotas)):
                        # Aplicar buffer nas coordenadas geográficas (latitude e longitude)
                            buffer = geom.buffer(buffer_size*(i+1), 5)
                            crs = massas.sourceCrs()
                            buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                            buffer_vector.dataProvider().addAttributes(massas.fields())
                            buffer_vector.updateFields()
                            buffer_feat = QgsFeature()
                            buffer_feat.setGeometry(buffer)
                            buffer_feat.setAttributes(massa.attributes())
                            buffer_vector.dataProvider().addFeatures([buffer_feat])
                            buffer_vector.updateExtents()
                            QgsProject.instance().addMapLayer(buffer_vector)
                            buffers.append(buffer_vector) #Lista de buffers em camada
                        feedback.pushInfo(f'A massa {massa} está com essa lista de buffers {buffers}.')

                    else:
                        
                        buffer_size = lim_aquidade * scale
                        feedback.pushInfo(f'Para a escala de 1/{scale}, no limite da aquidade visual de {lim_aquidade}m o buffer será de {buffer_size}m.')
                        feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                        for i in range (0, len(cotas)):
                            buffer = geom.buffer(buffer_size*(i+1), 5)
                            crs = massas.sourceCrs()
                            buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                            buffer_vector.dataProvider().addAttributes(massas.fields())
                            buffer_vector.updateFields()
                            buffer_feat = QgsFeature()
                            buffer_feat.setGeometry(buffer)
                            buffer_feat.setAttributes(massa.attributes())
                            buffer_vector.dataProvider().addFeatures([buffer_feat])
                            buffer_vector.updateExtents()
                            QgsProject.instance().addMapLayer(buffer_vector)
                            buffers.append(buffer_vector) #Lista de buffers em camada
                        feedback.pushInfo(f'A massa {massa} está com essa lista de buffers {buffers}.')
                        #feedback.setProgressText(f'A camada buffer {buffer} é do tipo {type(buffer)}')
                        # Adicionar a camada de buffer ao projeto
                       
                    feedback.setProgress(int(2 * total))
            
            
                # 3) Criação de uma camada de linhas no contorno do buffer
                boundaries = list()
                for buffer in buffers:
                    feedback.setProgressText('Extraindo o contorno das massas d\'água...')

                    boundary = processing.run("native:polygonstolines",
                                            {'INPUT': buffer,
                                            'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                    #feedback.setProgressText(f'A camada de linhas no contorno {boundary} é do tipo {type(boundary)}')
                    # Adicionar a camada de contorno ao projeto
                    boundary = processing.run("native:clip", 
                                              {'INPUT':boundary,
                                               'OVERLAY':moldura,
                                               'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
                    QgsProject.instance().addMapLayer(boundary)
                    boundaries.append(boundary)
                    feedback.pushInfo(f'A massa {massa} possui a seguinte lista de linhas de fronteira {boundaries}')
                feedback.setProgress(int(3 * total))#cotas_intersection.append(cotas)

                # 4) Secção da linha de contorno
                feedback.setProgressText('Seccionando o contorno das massas d\'água com curvas de nível...')

                split_boundaries = list()
                for boundary in boundaries:
                    split_boundary = processing.run("native:splitwithlines",
                                                    {'INPUT': boundary,
                                                    'LINES': curves,
                                                    'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                    
                    split_boundary = processing.run("native:splitwithlines",
                                                    {'INPUT': split_boundary,
                                                    'LINES': moldura_line,
                                                    'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT'] #Secção da linha pela moldura

                    # Adicionar a camada de contorno seccionada ao projeto
                    QgsProject.instance().addMapLayer(split_boundary)
                    split_boundaries.append(split_boundary)
                    #O ordenamento na lista, segue a lógica de ligar o primeiro elemento com a menor cota

                feedback.pushInfo(f'A massa {massa} possui a seguinte lista de linhas de fronteira {split_boundaries}')
                feedback.setProgress(int(4 * total))

                # 5) Criação das CN cortada pelo buffer
                feedback.setProgressText(f'Cortando as curvas de nível que intersectam massas d\'água...')

                feedback.pushInfo(f'Aqui o alcance da lista de buffers é {len(buffers)}.')
                feedback.pushInfo(f'Aqui o alcance da lista de split_boundaries é {len(split_boundaries)}.')
                for i in range (0,len(buffers)):
                    
                    cn_adequadas = processing.run("native:difference", 
                                                  {'INPUT':cn_adequadas,
                                                   'OVERLAY':buffers[i],
                                                   'OUTPUT':'TEMPORARY_OUTPUT',
                                                   'GRID_SIZE':None})['OUTPUT']
                    QgsProject.instance().addMapLayer(cn_adequadas)

                    feedback.setProgress(int(5 * total))

                
                    # 6) Substituição de trechos das curvas de nível
                    #AQUI, A CN_ADEQUADAS ESTÁ QUEBRADA PELO BUFFER

                    feedback.setProgressText("Iniciando a conexão das curvas de nível que foram cortadas...")
                    
                    feedback.pushInfo(f'Será realizada a linha na cota {cotas[i]}, que é do tipo {type(cotas[i])}')
                    split_boundary = split_boundaries[i]
                    for line_con in split_boundary.getFeatures():
                        line_con_geom = line_con.geometry()
                        line_con_geom_buffer = line_con.geometry().buffer(1, 5)
                        bbox = line_con_geom_buffer.boundingBox()

                        for line in cn_adequadas.getFeatures():
                            line_geom = line.geometry()

                            if line_con_geom_buffer.intersects(line_geom):
                                
                                for line_2 in cn_adequadas.getFeatures():
                                    line_2_geom = line_2.geometry()

                                    if line_con_geom_buffer.intersects(line_2_geom):
                                        if line.id() != line_2.id() and line.id() > line_2.id() and line[cota_field[0]] == cotas[i] and line_2[cota_field[0]] == cotas[i]:
                                            feedback.pushInfo(f"A conexão entre a cn {line.id()} e a cn {line_2.id()} são diferentes e conectadas por {line_con.id()}")
                                            feedback.pushInfo(f"E a cota entre eles é de {line[cota_field[0]]} que é {line_2[cota_field[0]]}.")
                                            new_feature = QgsFeature(cn_adequadas.fields())
                                            new_feature.setGeometry(line_con_geom)
                                            new_feature.setAttributes(line.attributes())
                                            cn_adequadas.addFeature(new_feature)
            cn_adequadas.commitChanges()
        #QgsProject.instance().addMapLayer(cn_adequadas)
                    
        return {self.OUTPUT: dest_id}
   
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "Adequar curvas de nível com massa d'água"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr("Adequar curvas de nível com massa d'água")

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CorrecaoCurvaNivelAlgorithm()
    
    def shortHelpString(self):
        return self.tr("Este processing identifica e adequa as curvas de nível que interceptam vetores de massa d'água à Norma da Especificação Técnica para Aquisição de Dados Geoespaciais Vetoriais (ET-ADVG) versão 3.0 (EB80-N-72.005)")
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(__file__), 'cn_agua.png'))

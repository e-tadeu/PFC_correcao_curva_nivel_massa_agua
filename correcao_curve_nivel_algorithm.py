# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CorrecaoCurvaNivel
                                 A QGIS plugin
 Este plugin identifica e corrige linhas de curva de nível que intersectam vetores de massa d'água.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-21
        copyright            : (C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius
        email                : e.tadeu.eb@ime.eb.br; joao.pereira@ime.eb.br; viniciusmagalhaes@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'
__date__ = '2023-11-21'
__copyright__ = '(C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
from code import interact
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import (QgsProcessing,
                       QgsFeature,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProcessingOutputVectorLayer,
                       QgsProcessingException,
                       QgsProject,
                       QgsVectorLayer,
                       QgsWkbTypes)
import processing
from math import cos, radians


class CorrecaoCurvaNivelAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    # Constantes usadas para referenciar os parâmetros e saídas
    INPUT_VECTOR = 'INPUT_VECTOR'
    INPUT_AGUA = 'INPUT_AGUA'
    INPUT_SCALE = 'INPUT_SCALE'
    CUSTOM_SCALE = 'CUSTOM_SCALE'
    BUFFER_SIZE = 'BUFFER_SIZE'
    OUTPUT = 'OUTPUT'
    SELECTED = 'SELECTED'
    
    def initAlgorithm(self, config=None):
        """
        Define os parâmetros de entrada e saída do algoritmo.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_VECTOR, 
                self.tr("Insira as curvas de nível"),
                [QgsProcessing.TypeVectorLine]
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SELECTED, self.tr("Process only selected features")
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_AGUA,
                self.tr("Insira a camada de massa d'água"),
                types=[QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterEnum(
                self.INPUT_SCALE,
                self.tr("Selecione a escala"),
                options=['1/25.000', '1/50.000', '1/100.000', '1/250.000', 'Personalizada'],
                defaultValue=0
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.CUSTOM_SCALE,
                self.tr("Insira a escala personalizada (apenas se 'Personalizada' for selecionada)"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_SIZE,
                self.tr("Tamanho do buffer em torno das massas d'água"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Curvas de Nível Ajustadas')
            )
        )
    
    def processAlgorithm(self, parameters, context, feedback):
        """
        Executa o processamento principal do algoritmo.
        """
        curvas = self.parameterAsVectorLayer(parameters, self.INPUT_VECTOR, context)
        massas = self.parameterAsVectorLayer(parameters, self.INPUT_AGUA, context)
        scale_option = self.parameterAsEnum(parameters, self.INPUT_SCALE, context)
        custom_scale = self.parameterAsDouble(parameters, self.CUSTOM_SCALE, context)
        buffer_size = self.parameterAsDouble(parameters, self.BUFFER_SIZE, context)
        onlySelected = self.parameterAsBool(parameters, self.SELECTED, context)

        # Criação de uma camada somente com as feições selecionadas
        if onlySelected == False: inputLayer = curvas
        else: 
            crs = curvas.sourceCrs()
            inputLayer = QgsVectorLayer(f"{QgsWkbTypes.displayString(curvas.wkbType())}?crs={crs.authid()}", "feições_selecionadas", "memory")
            inputLayer.dataProvider().addAttributes(curvas.fields())
            inputLayer.updateFields()
            inputFeat = curvas.selectedFeatures()
            inputLayer.dataProvider().addFeatures(inputFeat)
            inputLayer.updateExtents()
        
        # A variável scale refere-se ao denominador de escala
        if scale_option == 4:  # Personalizada
            if custom_scale <= 0:
                raise QgsProcessingException(self.tr("A escala personalizada deve ser um valor positivo."))
            scale = custom_scale
        else:
            scales = [25000, 50000, 100000, 250000]
            scale = scales[scale_option]

        (sink, dest_id) = self.parameterAsSink(parameters, 
                                               self.OUTPUT,
                                                context,
                                                curvas.fields(),
                                                QgsWkbTypes.LineString,
                                                curvas.sourceCrs())

        feedback.setProgressText('Procurando e corrigindo geometrias inválidas nas camadas de vetores...')

        # Correção de geometrias inválidas nas camadas de vetores
        curves = processing.run("native:fixgeometries",
                                {'INPUT':inputLayer,
                                 'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        water = processing.run("native:fixgeometries", 
                               {'INPUT':massas,
                                'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        total = 100.0 / 6

        feedback.setProgressText('Procurando e identificando as intersecções entre as camadas de vetores...')

        # 1) Obtenção da intersecção das curvas de nível com as massas d'água
        intersection = processing.run("native:intersection",
                                      {'INPUT':curves,
                                       'OVERLAY':water,
                                       'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        #feedback.setProgressText(f'A camada buffer {intersection} é do tipo {type(intersection)}')
        QgsProject.instance().addMapLayer(intersection)
        feedback.setProgress(int(1 * total))

        # 2) Inserção de uma camada de buffer em torno das massas d'água
        if buffer_size:
            feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
            
            #Caso seja um buffer personalizado, ele verifica se o sistema é geográfico e converte no equivalente a graus
            if curvas.crs().isGeographic():
                extent = curvas.extent()
                centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                buffer_size_graus = buffer_size / (111320 * cos(radians(centroid_lat)))
                feedback.pushInfo(f'Para sistema de coordenadas geográficas, o buffer de {buffer_size} será de {buffer_size_graus}° na latitude média de {centroid_lat}°.')
                buffer = processing.run("native:buffer",
                                        {'INPUT': water,
                                        'DISTANCE': buffer_size_graus,
                                        'SEGMENTS': 5,
                                        'DISSOLVE': True,
                                        'END_CAP_STYLE': 0,
                                        'JOIN_STYLE': 0,
                                        'MITER_LIMIT': 2,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                
            else:
                buffer = processing.run("native:buffer",
                                        {'INPUT': water,
                                        'DISTANCE': buffer_size,
                                        'SEGMENTS': 5,
                                        'DISSOLVE': True,
                                        'END_CAP_STYLE': 0,
                                        'JOIN_STYLE': 0,
                                        'MITER_LIMIT': 2,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                
                #feedback.setProgressText(f'A camada buffer {buffer} é do tipo {type(buffer)}')
                # Adicionar a camada de buffer ao projeto
                #QgsProject.instance().addMapLayer(buffer)

        else:
            lim_aquidade = 0.0002 # O limite da aquidade visual é de 0,2mm (0,0002m)
            if curvas.crs().isGeographic():
                extent = curvas.extent()
                centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                buffer_size_meters = lim_aquidade * scale
                buffer_size = buffer_size_meters / (111320 * cos(radians(centroid_lat)))

                feedback.pushInfo(f'Para a escala de 1/{scale}, o buffer será de {buffer_size}° na latitude média de {centroid_lat}°.')
                feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                
                # Aplicar buffer nas coordenadas geográficas (latitude e longitude)
                buffer = processing.run("native:buffer",
                                        {'INPUT': water,
                                        'DISTANCE': buffer_size,  # Assumindo que estamos aplicando apenas em latitude
                                        'SEGMENTS': 5,
                                        'DISSOLVE': True,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

            else:
                
                buffer_size = lim_aquidade * scale
                feedback.pushInfo(f'Para a escala de 1/{scale}, no limite da aquidade visual de {lim_aquidade}m o buffer será de {buffer_size}m.')
                feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                buffer = processing.run("native:buffer",
                                        {'INPUT': water,
                                        'DISTANCE': buffer_size,
                                        'SEGMENTS': 5,
                                        'DISSOLVE': True,
                                        'END_CAP_STYLE': 0,
                                        'JOIN_STYLE': 0,
                                        'MITER_LIMIT': 2,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                
                #feedback.setProgressText(f'A camada buffer {buffer} é do tipo {type(buffer)}')
                # Adicionar a camada de buffer ao projeto
                #QgsProject.instance().addMapLayer(buffer)
            feedback.setProgress(int(2 * total))

            # 3) Criação de uma camada de linhas no contorno do buffer
            feedback.setProgressText('Extraindo o contorno das massas d\'água...')

            boundary = processing.run("native:polygonstolines",
                                    {'INPUT': buffer,
                                    'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
            #feedback.setProgressText(f'A camada de linhas no contorno {boundary} é do tipo {type(boundary)}')
            # Adicionar a camada de contorno ao projeto
            #QgsProject.instance().addMapLayer(boundary)
            feedback.setProgress(int(3 * total))

        # 4) Secção da linha de contorno
        feedback.setProgressText('Seccionando o contorno das massas d\'água com curvas de nível...')

        split_boundary = processing.run("native:splitwithlines",
                                        {'INPUT': boundary,
                                         'LINES': curves,
                                         'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

        # Adicionar a camada de contorno seccionada ao projeto
        #QgsProject.instance().addMapLayer(split_boundary)
        feedback.setProgress(int(4 * total))

        # 5) Criação das CN cortada pelo buffer
        feedback.setProgressText(f'Cortando as curvas de nível que intersectam massas d\'água...')

        #lista de geometrias do buffer de massas de água
        water_bodies_buffered = [feat.geometry() for feat in buffer.getFeatures()]

        cn_cortadas_feats = list()
        for contour in curves.getFeatures():
            contour_geom = contour.geometry()
            new_geoms = [contour_geom]
            
            for buffer in water_bodies_buffered:
                temp_geoms = []
                for geom in new_geoms:
                    if geom.intersects(buffer):
                        split_geoms = geom.difference(buffer)
                        temp_geoms.extend(split_geoms.asGeometryCollection())
                    else:
                        temp_geoms.append(geom)
                new_geoms = temp_geoms
            
            for new_geom in new_geoms:
                new_feature = QgsFeature(curves.fields())
                new_feature.setGeometry(new_geom)
                new_feature.setAttributes(contour.attributes())  # Mantém os atributos originais
                cn_cortadas_feats.append(new_feature)

        cn_cortadas_layer = QgsVectorLayer(f"LineString?crs={curves.crs().authid()}",
                                     "cn_cortadas_agua",
                                     "memory")
        cn_cortadas_layer.dataProvider().addAttributes(curves.fields())
        cn_cortadas_layer.updateFields()
        cn_cortadas_layer.dataProvider().addFeatures(cn_cortadas_feats)
        cn_cortadas_layer.updateExtents()
        #feedback.setProgressText(f'A camada {cn_cortadas_layer} é do tipo {type(cn_cortadas_layer)}.')
        feedback.setProgress(int(5 * total))

        # 6) Substituição de trechos das curvas de nível
        #Coletar feições das Curvas de Nível segmentada com pontas soltas

        feedback.setProgressText("Iniciando a conexão das curvas de nível que foram cortadas...")
        
        for line_con in split_boundary.getFeatures():
            line_con_geom = line_con.geometry()
            line_con_geom_buffer = line_con.geometry().buffer(1, 5)
            bbox = line_con_geom_buffer.boundingBox()

            #feedback.pushInfo(f"Analisando o segmento de conexão {line_con.id()}")

            for line in cn_cortadas_layer.getFeatures(bbox):
                line_geom = line.geometry()

                if line_con_geom_buffer.intersects(line_geom):
                    
                    for line_2 in cn_cortadas_layer.getFeatures(bbox):
                        line_2_geom = line_2.geometry()

                        if line_con_geom_buffer.intersects(line_2_geom):
                            if line.id() != line_2.id() and line.id() > line_2.id() and line['cota'] == line_2['cota']:
                                #feedback.pushInfo(f"A conexão entre a cn {line.id()} e a cn {line_2.id()} são diferentes e conectadas por {line_con.id()}")
                                #feedback.pushInfo(f"E a cota entre eles é de {line['cota']} que é {line_2['cota']}.")
                                new_feature = QgsFeature(cn_cortadas_layer.fields())
                                new_feature.setGeometry(line_con_geom)
                                new_feature.setAttributes(line.attributes())
                                cn_cortadas_feats.append(new_feature)
        
        # Criar nova feature com as geometrias conectadas
        for new_feat in cn_cortadas_feats:
            sink.addFeature(new_feat, QgsFeatureSink.FastInsert)

        feedback.setProgressText("Adequação das curvas de nível concluída.")
        feedback.setProgress(int(6 * total))
        
        return {self.OUTPUT: dest_id}
   
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "Adequar curvas de nível com massa d'água"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr("Adequar curvas de nível com massa d'água")

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CorrecaoCurvaNivelAlgorithm()
    
    def shortHelpString(self):
        return self.tr("Este processing identifica e adequa as curvas de nível que interceptam vetores de massa d'água à Norma da Especificação Técnica para Aquisição de Dados Geoespaciais Vetoriais (ET-ADVG) versão 3.0 (EB80-N-72.005)")
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(__file__), 'cn_agua.png'))

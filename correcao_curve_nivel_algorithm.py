# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CorrecaoCurvaNivel
                                 A QGIS plugin
 Este plugin identifica e corrige linhas de curva de nível que intersectam vetores de massa d'água.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-21
        copyright            : (C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius
        email                : e.tadeu.eb@ime.eb.br; joao.pereira@ime.eb.br; viniciusmagalhaes@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'
__date__ = '2023-11-21'
__copyright__ = '(C) 2023 by Cap Tadeu; 1° Ten Kreitlon; 1° Ten Vinicius'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterVectorLayer,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsFeatureSink,
    QgsGeometry,
    QgsWkbTypes,
    QgsProcessing,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterEnum,
    QgsProcessingException,
    QgsProcessingParameterField,
    QgsProject,
    QgsVectorLayer
)
import processing
from qgis.PyQt.QtCore import QVariant, QCoreApplication
from math import cos, radians


class CorrecaoCurvaNivelAlgorithm(QgsProcessingAlgorithm):

    INPUT_VECTOR = 'INPUT_VECTOR'
    INPUT_FIELD =  'INPUT_FIELD'
    INPUT_AGUA = 'INPUT_AGUA'
    INPUT_SCALE = 'INPUT_SCALE'
    CUSTOM_SCALE = 'CUSTOM_SCALE'
    BUFFER_SIZE = 'BUFFER_SIZE'
    OUTPUT = 'OUTPUT'
    SELECTED = 'SELECTED'
    MOLDURA = 'MOLDURA'
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_VECTOR, 
                self.tr("Insira as curvas de nível"),
                [QgsProcessing.TypeVectorLine]
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SELECTED, self.tr("Process only selected features")
            )
        )
        self.addParameter(
            QgsProcessingParameterField(
                'INPUT_FIELD',
                self.tr('Selecione o atributo de cota'), 
                type=QgsProcessingParameterField.Numeric, 
                parentLayerParameterName='INPUT_VECTOR',
                defaultValue = 'cota')
            )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_AGUA,
                self.tr("Insira a camada de massa d'água"),
                types=[QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterEnum(
                self.INPUT_SCALE,
                self.tr("Selecione a escala"),
                options=['1/25.000', '1/50.000', '1/100.000', '1/250.000', 'Personalizada'],
                defaultValue=0
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.CUSTOM_SCALE,
                self.tr("Insira a escala personalizada (apenas se 'Personalizada' for selecionada)"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_SIZE,
                self.tr("Tamanho do buffer em torno das massas d'água"),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.MOLDURA,
                self.tr("Insira a camada de moldura"),
                types=[QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Curvas de Nível Ajustadas')
            )
        )
    
    def processAlgorithm(self, parameters, context, feedback):
        """
        Executa o processamento principal do algoritmo.
        """
        curvas = self.parameterAsVectorLayer(parameters, self.INPUT_VECTOR, context)
        cota_field = self.parameterAsFields(parameters,'INPUT_FIELD', context )
        massas = self.parameterAsVectorLayer(parameters, self.INPUT_AGUA, context)
        scale_option = self.parameterAsEnum(parameters, self.INPUT_SCALE, context)
        custom_scale = self.parameterAsDouble(parameters, self.CUSTOM_SCALE, context)
        buffer_size = self.parameterAsDouble(parameters, self.BUFFER_SIZE, context)
        onlySelected = self.parameterAsBool(parameters, self.SELECTED, context)
        moldura = self.parameterAsVectorLayer(parameters, self.MOLDURA, context)

        # Criação de uma camada somente com as feições selecionadas
        if onlySelected == False: inputLayer = curvas
        else: 
            crs = curvas.sourceCrs()
            inputLayer = QgsVectorLayer(f"{QgsWkbTypes.displayString(curvas.wkbType())}?crs={crs.authid()}", "feições_selecionadas", "memory")
            inputLayer.dataProvider().addAttributes(curvas.fields())
            inputLayer.updateFields()
            inputFeat = curvas.selectedFeatures()
            inputLayer.dataProvider().addFeatures(inputFeat)
            inputLayer.updateExtents()
        
        # A variável scale refere-se ao denominador de escala
        if scale_option == 4:  # Personalizada
            if custom_scale <= 0:
                raise QgsProcessingException(self.tr("A escala personalizada deve ser um valor positivo."))
            scale = custom_scale
        else:
            scales = [25000, 50000, 100000, 250000]
            scale = scales[scale_option]

        (sink, dest_id) = self.parameterAsSink(parameters, 
                                               self.OUTPUT,
                                                context,
                                                curvas.fields(),
                                                QgsWkbTypes.LineString,
                                                curvas.sourceCrs())

        feedback.setProgressText('Procurando e corrigindo geometrias inválidas nas camadas de vetores...')

        # Correção de geometrias inválidas nas camadas de vetores
        curves = processing.run("native:fixgeometries",
                                {'INPUT':inputLayer,
                                 'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        water = processing.run("native:fixgeometries", 
                               {'INPUT':massas,
                                'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        total = 100.0 / water.featureCount() if water.featureCount() else 0

        moldura_line = processing.run("native:polygonstolines",
                                {'INPUT': moldura,
                                'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

        feedback.setProgressText('Procurando e identificando as intersecções entre as camadas de vetores...')

        # 1) Obtenção da intersecção das curvas de nível com as massas d'água

        intersection = self.interseccao(parameters, context, curves, water)

        cn_adequadas = curves

        for current, massa_feat in enumerate(water.getFeatures()):
            
            if feedback.isCanceled():
                break

            massa_geom = massa_feat.geometry()
            cotas_list = list()

            for line in intersection.getFeatures():
                geom_inter = line.geometry()

                if geom_inter.intersects(massa_geom):
                    cota = line[cota_field[0]] #Aqui ele pega a string 'cota'
                    cotas_list.append(cota)
                    feedback.pushInfo(f'A feição {line} possui a cota {cota} e está dentro da massa {massa_feat}.')
            
            cotas_list = sorted(set(cotas_list)) #Elementos únicos (sem cotas duplicadas) e crescentemente ordenadas
            
            if len(cotas_list) > 0:
                
                # 2) Inserção de n camada de buffer em torno da massa d'água
                feedback.setProgressText(f'\nAplicando {len(cotas_list)} buffers ao redor da massa d\'água {massa_feat.id()}...')
                buffers_list = self.list_buffers(parameters, context, buffer_size, curvas, massas, massa_feat, massa_geom, cotas_list, scale)                      
                feedback.setProgress(int(2 * total))
            
                # 3) Criação de uma camada de linhas no contorno do buffer
                feedback.setProgressText(f'\nExtraindo o contorno dos buffers da massas d\'água {massa_feat.id()}...')
                boundaries_list = self.contour_buffer(parameters, context, buffers_list, moldura)
                feedback.pushInfo(f'A massa {massa_feat} possui {len(boundaries_list)} contorno de buffers com as seguintes camadas {boundaries_list}.')
                feedback.setProgress(int(3 * total))
                
                # 4) Secção da linha de contorno
                feedback.setProgressText(f'\nSeccionando o contorno dos buffers da massa d\'água {massa_feat.id()} com curvas de nível...')
                split_boundaries_list = self.split_contour(parameters, context, feedback, boundaries_list, curves, moldura_line, cotas_list, cota_field[0])
                feedback.pushInfo(f'A massa {massa_feat} possui {len(split_boundaries_list)} contorno de buffers seccionados pelas CN com as seguintes camadas {split_boundaries_list}.')
                #O ordenamento na lista, segue a lógica de ligar o primeiro elemento com a menor cota
                feedback.setProgress(int(4 * total))

                feedback.pushInfo(f'\nO alcance da lista de buffer é {len(buffers_list)} de cota é {len(cotas_list)} e da split_boundaries {len(split_boundaries_list)}.')
                for b in range (0,len(buffers_list)): 
                    # 5) Criação das CN cortada pelo buffer
                    feedback.setProgressText(f'\nCortando as curvas de nível que intersectam o buffer da massa d\'água {massa_feat.id()}...')
                    cn_adequadas = self.cut_cn(parameters, context, feedback, cn_adequadas, buffers_list[b], cota_field[0], cotas_list[b])
                    feedback.pushInfo(f'O recorte das CN {cn_adequadas} pelo buffer {buffers_list[b]} de cota {cotas_list[b]}.')
                    feedback.setProgress(int(5 * total))
                
                    # 6) Substituição de trechos das curvas de nível
                    feedback.setProgressText(f"\nIniciando a conexão das curvas de nível que foram cortadas...")
                    cn_adequadas = self.substituicao_trecho(parameters, context, feedback, split_boundaries_list[b], cn_adequadas, cota_field[0], cotas_list[b])
        
            feedback.setProgress(int(current * total))
        
        # Adição das feições na camada output
        for feat in cn_adequadas.getFeatures():
            sink.addFeature(feat, QgsFeatureSink.FastInsert)
        
        return {self.OUTPUT: dest_id}

    def interseccao(self, parameter, context, curves, water):

        intersection = processing.run("native:intersection",
                                      {'INPUT':curves,
                                       'OVERLAY':water,
                                       'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

        intersection = processing.run("native:multiparttosingleparts", 
                                      {'INPUT': intersection,
                                       'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        QgsProject.instance().addMapLayer(intersection)

        return intersection

    def list_buffers(self, parameters, context, buffer_size, curvas, massas, massa_feat, massa_geom, cotas, scale):
        
        buffers = list()
        if buffer_size:
                                
            #Caso seja um buffer personalizado, ele verifica se o sistema é geográfico e converte no equivalente a graus
            if curvas.crs().isGeographic():
                extent = curvas.extent()
                centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                buffer_size_graus = buffer_size / (111320 * cos(radians(centroid_lat)))
                #feedback.pushInfo(f'Para sistema de coordenadas geográficas, o buffer de {buffer_size} será de {buffer_size_graus}° na latitude média de {centroid_lat}°.')
                
                for i in range (0, len(cotas)):
                    buffer = massa_geom.buffer(buffer_size_graus*(i+1), 5)
                    crs = massas.sourceCrs()
                    buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                    buffer_vector.dataProvider().addAttributes(massas.fields())
                    buffer_vector.updateFields()
                    buffer_feat = QgsFeature()
                    buffer_feat.setGeometry(buffer)
                    buffer_feat.setAttributes(massa_geom.attributes())
                    buffer_vector.dataProvider().addFeatures([buffer_feat])
                    buffer_vector.updateExtents()
                    
                    QgsProject.instance().addMapLayer(buffer_vector)
                    buffers.append(buffer_vector) #Lista de buffers em camada

                
            else:
                for i in range (0, len(cotas)):
                    buffer = massa_geom.buffer(buffer_size*(i+1), 5)
                    crs = massas.sourceCrs()
                    buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                    buffer_vector.dataProvider().addAttributes(massas.fields())
                    buffer_vector.updateFields()
                    buffer_feat = QgsFeature()
                    buffer_feat.setGeometry(buffer)
                    buffer_feat.setAttributes(massa_feat.attributes())
                    buffer_vector.dataProvider().addFeatures([buffer_feat])
                    buffer_vector.updateExtents()
                    QgsProject.instance().addMapLayer(buffer_vector)
                    buffers.append(buffer_vector) #Lista de buffers em camada             

        else:
            lim_aquidade = 0.0002 # O limite da aquidade visual é de 0,2mm (0,0002m)
            if curvas.crs().isGeographic():
                extent = curvas.extent()
                centroid_lat = (extent.yMinimum() + extent.yMaximum()) / 2 #Pega a latitude do centroide do projeto
                buffer_size_meters = lim_aquidade * scale
                buffer_size = buffer_size_meters / (111320 * cos(radians(centroid_lat)))

                #feedback.pushInfo(f'Para a escala de 1/{scale}, o buffer será de {buffer_size}° na latitude média de {centroid_lat}°.')
                #feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                
                for i in range (0, len(cotas)):
                # Aplicar buffer nas coordenadas geográficas (latitude e longitude)
                    buffer = massa_geom.buffer(buffer_size*(i+1), 5)
                    crs = massas.sourceCrs()
                    buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                    buffer_vector.dataProvider().addAttributes(massas.fields())
                    buffer_vector.updateFields()
                    buffer_feat = QgsFeature()
                    buffer_feat.setGeometry(buffer)
                    buffer_feat.setAttributes(massa_feat.attributes())
                    buffer_vector.dataProvider().addFeatures([buffer_feat])
                    buffer_vector.updateExtents()
                    QgsProject.instance().addMapLayer(buffer_vector)
                    buffers.append(buffer_vector) #Lista de buffers em camada

            else:
                
                buffer_size = lim_aquidade * scale
                #feedback.pushInfo(f'Para a escala de 1/{scale}, no limite da aquidade visual de {lim_aquidade}m o buffer será de {buffer_size}m.')
                #feedback.setProgressText('Aplicando buffer ao redor das massas d\'água...')
                for i in range (0, len(cotas)):
                    buffer = massa_geom.buffer(buffer_size*(i+1), 5)
                    crs = massas.sourceCrs()
                    buffer_vector = QgsVectorLayer(f"{QgsWkbTypes.displayString(massas.wkbType())}?crs={crs.authid()}", "buffer", "memory")
                    buffer_vector.dataProvider().addAttributes(massas.fields())
                    buffer_vector.updateFields()
                    buffer_feat = QgsFeature()
                    buffer_feat.setGeometry(buffer)
                    buffer_feat.setAttributes(massa_feat.attributes())
                    buffer_vector.dataProvider().addFeatures([buffer_feat])
                    buffer_vector.updateExtents()
                    QgsProject.instance().addMapLayer(buffer_vector)
                    buffers.append(buffer_vector) #Lista de buffers em camada

        return buffers

    def contour_buffer(self, parameters, context, buffers_list, moldura):
        
        boundaries = list()

        for buffer in buffers_list:
            boundary = processing.run("native:polygonstolines",
                                    {'INPUT': buffer,
                                    'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

            boundary = processing.run("native:clip", 
                                        {'INPUT':boundary,
                                        'OVERLAY':moldura,
                                        'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
            QgsProject.instance().addMapLayer(boundary)
            boundaries.append(boundary)
        
        return boundaries

    def split_contour(self, parameters, context, feedback, boundaries, curves, moldura_line, cotas_list, cota_field):

        split_boundaries = list()
        for f in range (0, len(boundaries)):
            # Filtrar feições da moldura_line com base no atributo desejado (exemplo: 'category' == 1)
            atributo = cota_field #nome do atributo
            valor_cota = cotas_list[f] #A lista de cotas crescente está par a par com o buffer
            #feedback.pushInfo(f'A camada temporária usa seu atributo de campo {atributo} com valor {valor_cota} para cortar a fronteira.')
            # Criar uma nova camada temporária com as feições filtradas
            features_filtradas = [feat for feat in curves.getFeatures() if feat[atributo] == valor_cota]
            #feedback.pushInfo(f'As feições atributo de campo {atributo} com valor {valor_cota} são essas {features_filtradas}.')
            crs = curves.sourceCrs()
            mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(curves.wkbType())}?crs={crs.authid()}", "feições_selecionadas", "memory")
            mem_layer.dataProvider().addAttributes(curves.fields())
            mem_layer.updateFields()
            mem_layer.dataProvider().addFeatures(features_filtradas)
            mem_layer.updateExtents()
            #QgsProject.instance().addMapLayer(mem_layer)
            # Executar o algoritmo de divisão com a camada filtrada
            split_boundary = processing.run("native:splitwithlines",
                                            {'INPUT': boundaries[f],
                                            'LINES': mem_layer,
                                            'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
            
            split_boundary = processing.run("native:splitwithlines",
                                            {'INPUT': split_boundary,
                                            'LINES': moldura_line,
                                            'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT'] #Secção da linha pela moldura

            # Adicionar a camada de contorno seccionada ao projeto
            QgsProject.instance().addMapLayer(split_boundary)
            split_boundaries.append(split_boundary)
        return split_boundaries

    def cut_cn(self, parameters, context, feedback, cn_adequadas, buffer_layer, cota_field, cota):        
             
        # Atributo e valor da cota a ser filtrado
        atributo = cota_field #atributo 'cota'
        valor_cota = cota #valor de cota filtrado

        # Criar uma nova camada de memória para armazenar as feições modificadas
        crs = cn_adequadas.sourceCrs()
        mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(cn_adequadas.wkbType())}?crs={crs.authid()}", f"CN_cortada_na_cota_{valor_cota}", "memory")
        mem_layer.dataProvider().addAttributes(cn_adequadas.fields())
        mem_layer.updateFields()

        trechos = list()
        # Iterar sobre as feições da camada de linhas
        for line_feat in cn_adequadas.getFeatures():
            line_geom = line_feat.geometry()

            # Verificar se a feição atende ao critério de cota
            if line_feat[atributo] == valor_cota:
                # Aplicação da diferença (difference) com cada geometria da camada de buffer
                for buffer_feat in buffer_layer.getFeatures():
                    buffer_geom = buffer_feat.geometry()
                    
                    # Aplicar a diferença
                    diff_geom = line_geom.difference(buffer_geom)

                    # Criação de uma nova feição para armazenar a geometria resultante
                    new_feature = QgsFeature()
                    new_feature.setGeometry(diff_geom)
                    new_feature.setAttributes(line_feat.attributes())  # Manter os atributos da linha original
                    
                    # Adicionar a feição resultante à camada de memória
                    trechos.append(new_feature)

            else:
                # Se não for a feição com cota desejada, adicionar a feição original
                trechos.append(line_feat)

        # Atualizar a extensão da nova camada
        mem_layer.dataProvider().addFeatures(trechos)
        mem_layer.updateExtents()

        cn_adequadas = processing.run("native:multiparttosingleparts", 
                        {'INPUT': mem_layer,
                        'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        # Adicionar a nova camada ao projeto
        QgsProject.instance().addMapLayer(cn_adequadas)

        return cn_adequadas
    
    def substituicao_trecho(self, parameters, context, feedback, split_boundary, cn_cortadas_layer, cota_field, cota):
        
        feedback.pushInfo(f'A camada de trechos de substituição é {split_boundary}.')

        trechos_feat = list()
        for line_con in split_boundary.getFeatures():
            line_con_geom = line_con.geometry()
            line_con_geom_buffer = line_con.geometry().buffer(1, 5)
            bbox = line_con_geom_buffer.boundingBox()

            for line in cn_cortadas_layer.getFeatures(bbox):
                line_geom = line.geometry()

                if line_con_geom_buffer.intersects(line_geom):
                    
                    for line_2 in cn_cortadas_layer.getFeatures(bbox):
                        line_2_geom = line_2.geometry()

                        if line_con_geom_buffer.intersects(line_2_geom):
                            if line.id() != line_2.id() and line.id() > line_2.id() and line[cota_field] == cota and line_2[cota_field] == cota:
                                feedback.pushInfo(f'A linha de conexão {line_con} conecta as linhas {line.id()} de cota {line[cota_field]} e {line_2.id()} de cota {line_2[cota_field]}.')
                                new_feature = QgsFeature(cn_cortadas_layer.fields())
                                new_feature.setGeometry(line_con_geom)
                                new_feature.setAttributes(line.attributes())
                                trechos_feat.append(new_feature)
        feedback.pushInfo(f'\nTemos a seguinte lista {trechos_feat} a ser adicionada na camada {cn_cortadas_layer}.')
        cn_cortadas_layer.dataProvider().addFeatures(trechos_feat)
        cn_cortadas_layer.updateExtents()
        QgsProject.instance().addMapLayer(cn_cortadas_layer)
        return cn_cortadas_layer
   
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "Adequar curvas de nível com massa d'água"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr("Adequar curvas de nível com massa d'água")

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CorrecaoCurvaNivelAlgorithm()
    
    def shortHelpString(self):
        return self.tr("Este processing identifica e adequa as curvas de nível que interceptam vetores de massa d'água à Norma da Especificação Técnica para Aquisição de Dados Geoespaciais Vetoriais (ET-ADVG) versão 3.0 (EB80-N-72.005)")
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(__file__), 'cn_agua.png'))
